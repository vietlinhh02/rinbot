const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const { getUserRin, updateUserRin } = require('../../utils/database');
const { BOARD, CHANCE_CARDS, COMMUNITY_CHEST_CARDS } = require('../../utils/constants');

// Game rooms storage
const rooms = new Map();

// Utility functions
function rollDice() {
    return Math.floor(Math.random() * 6) + 1;
}

function getRandomCard(cards) {
    return cards[Math.floor(Math.random() * cards.length)];
}

// Create game board status
function createBoardStatus(channelId) {
    const room = rooms.get(channelId);
    if (!room) return null;

    let status = 'üé≤ **C·ªú T·ª∂ PH√ö - B·∫¢NG TR·∫†NG TH√ÅI**\n\n';
    
    // Players info
    for (const [userId, player] of Object.entries(room.players)) {
        const position = BOARD[player.position];
        status += `üë§ **${player.user.displayName}**\n`;
        status += `üí∞ ${player.money} Nene | üìç ${position.name}\n\n`;
    }

    return status;
}

// Handle property interaction
async function handleProperty(channel, channelId, playerId) {
    const room = rooms.get(channelId);
    const player = room.players[playerId];
    const position = BOARD[player.position];

    if (position.type === 'land') {
        // Check if property is owned
        const owner = room.properties[player.position];
        
        if (!owner) {
            // Property is available for purchase
            if (player.money >= position.price) {
                const embed = new EmbedBuilder()
                    .setTitle('üè† Mua ƒë·∫•t?')
                    .setDescription(`**${position.name}**\nGi√°: ${position.price} Nene\nTi·ªÅn c·ªßa b·∫°n: ${player.money} Nene`)
                    .setColor('#0099FF');

                const buyButton = new ButtonBuilder()
                    .setCustomId(`buy_property_${playerId}`)
                    .setLabel('üí∞ Mua')
                    .setStyle(ButtonStyle.Success);

                const skipButton = new ButtonBuilder()
                    .setCustomId(`skip_property_${playerId}`)
                    .setLabel('‚ùå B·ªè qua')
                    .setStyle(ButtonStyle.Secondary);

                const row = new ActionRowBuilder().addComponents(buyButton, skipButton);
                await channel.send({ embeds: [embed], components: [row] });
                return true; // Wait for user action
            }
        } else if (owner !== playerId) {
            // Pay rent
            const rent = position.rent[0]; // Base rent
            player.money -= rent;
            room.players[owner].money += rent;

            const embed = new EmbedBuilder()
                .setTitle('üí∏ Tr·∫£ ti·ªÅn thu√™!')
                .setDescription(`${player.user.displayName} tr·∫£ ${rent} Nene cho ${room.players[owner].user.displayName}`)
                .setColor('#FF4500');

            await channel.send({ embeds: [embed] });
        }
    } else if (position.type === 'chance') {
        const card = getRandomCard(CHANCE_CARDS);
        await handleChanceCard(channel, playerId, card);
    } else if (position.type === 'community_chest') {
        const card = getRandomCard(COMMUNITY_CHEST_CARDS);
        await handleCommunityCard(channel, playerId, card);
    }

    return false; // Continue turn
}

// Handle chance card
async function handleChanceCard(channel, playerId, card) {
    const room = rooms.get(channel.id);
    const player = room.players[playerId];
    const [description, effect] = card;

    const embed = new EmbedBuilder()
        .setTitle('üé¥ Th·∫ª H√™n Xui!')
        .setDescription(description)
        .setColor('#FF69B4');

    if (typeof effect === 'number') {
        player.money += effect;
        embed.addFields({ name: 'K·∫øt qu·∫£', value: `${effect > 0 ? '+' : ''}${effect} Nene`, inline: false });
    } else if (effect === 'jail') {
        player.position = 7; // Jail position
        player.inJail = true;
        embed.addFields({ name: 'K·∫øt qu·∫£', value: 'V√†o t√π!', inline: false });
    } else if (effect === 'extra_turn') {
        room.extraTurn = true;
        embed.addFields({ name: 'K·∫øt qu·∫£', value: 'ƒê∆∞·ª£c l∆∞·ª£t ƒëi n·ªØa!', inline: false });
    }

    await channel.send({ embeds: [embed] });
}

// Handle community card
async function handleCommunityCard(channel, playerId, card) {
    const room = rooms.get(channel.id);
    const player = room.players[playerId];
    const [description, effect] = card;

    const embed = new EmbedBuilder()
        .setTitle('üéÅ √î V·∫≠n M·ªánh!')
        .setDescription(description)
        .setColor('#00FF00');

    if (typeof effect === 'number') {
        player.money += effect;
        embed.addFields({ name: 'K·∫øt qu·∫£', value: `+${effect} Nene`, inline: false });
    }

    await channel.send({ embeds: [embed] });
}

// Next turn
async function nextTurn(channel, channelId) {
    const room = rooms.get(channelId);
    if (!room) return;

    if (!room.extraTurn) {
        room.currentTurn = (room.currentTurn + 1) % room.turnOrder.length;
    }
    room.extraTurn = false;

    const currentPlayerId = room.turnOrder[room.currentTurn];
    const currentPlayer = room.players[currentPlayerId];

    // Check if game should end (someone bankrupt or time limit)
    if (currentPlayer.money <= 0) {
        await endGame(channel, channelId);
        return;
    }

    const embed = new EmbedBuilder()
        .setTitle('üéØ L∆∞·ª£t ti·∫øp theo!')
        .setDescription(`L∆∞·ª£t c·ªßa ${currentPlayer.user.displayName}!\nB·∫•m n√∫t ƒë·ªÉ tung x√∫c x·∫Øc!`)
        .setColor('#0099FF');

    const rollButton = new ButtonBuilder()
        .setCustomId(`roll_dice_${currentPlayerId}`)
        .setLabel('üé≤ Tung x√∫c x·∫Øc')
        .setStyle(ButtonStyle.Primary);

    const row = new ActionRowBuilder().addComponents(rollButton);
    await channel.send({ embeds: [embed], components: [row] });

    // Update status
    const statusEmbed = new EmbedBuilder()
        .setDescription(createBoardStatus(channelId))
        .setColor('#FFD700');
    
    if (room.statusMessage) {
        await room.statusMessage.edit({ embeds: [statusEmbed] });
    }
}

// End game
async function endGame(channel, channelId) {
    const room = rooms.get(channelId);
    if (!room) return;

    // Find winner (player with most money)
    let winner = null;
    let maxMoney = -1;

    for (const [userId, player] of Object.entries(room.players)) {
        if (player.money > maxMoney) {
            maxMoney = player.money;
            winner = player;
        }
    }

    const embed = new EmbedBuilder()
        .setTitle('üèÜ K·∫æT TH√öC C·ªú T·ª∂ PH√ö!')
        .setColor('#FFD700');

    if (winner) {
        embed.setDescription(`üéâ **${winner.user.displayName}** chi·∫øn th·∫Øng v·ªõi **${maxMoney} Nene**!`);
        
        // Give Rin reward for winner (optional)
        const rinReward = 500; // 500 Rin reward
        await updateUserRin(winner.user.id, rinReward);
        embed.addFields({ name: 'Ph·∫ßn th∆∞·ªüng', value: `+${rinReward} Rin cho ng∆∞·ªùi th·∫Øng!`, inline: false });
    }

    // Final rankings
    const rankings = Object.values(room.players)
        .sort((a, b) => b.money - a.money)
        .map((player, index) => `${index + 1}. ${player.user.displayName}: ${player.money} Nene`)
        .join('\n');

    embed.addFields({ name: 'B·∫£ng x·∫øp h·∫°ng', value: rankings, inline: false });

    await channel.send({ embeds: [embed] });
    rooms.delete(channelId);
}

module.exports = {
    name: 'typhu',
    description: 'M·ªü ph√≤ng C·ªù T·ª∑ Ph√∫',
    
    async execute(message, args) {
        const channelId = message.channel.id;

        if (rooms.has(channelId)) {
            return message.reply('‚ùå ƒê√£ c√≥ ph√≤ng C·ªù T·ª∑ Ph√∫ trong k√™nh n√†y!');
        }

        const room = {
            host: message.author,
            players: {},
            properties: {}, // position -> ownerId
            started: false,
            currentTurn: 0,
            turnOrder: [],
            extraTurn: false,
            statusMessage: null
        };

        rooms.set(channelId, room);

        const embed = new EmbedBuilder()
            .setTitle('üé≤ C·ªú T·ª∂ PH√ö ƒêANG M·ªû!')
            .setDescription('B·∫•m ƒë·ªÉ tham gia game!\n\n' +
                'üí∞ **Ph√≠ tham gia:** 100 Rin\n' +
                'üíé **Ti·ªÅn kh·ªüi ƒë·∫ßu:** 2000 Nene (trong game)\n' +
                'üèÜ **Ph·∫ßn th∆∞·ªüng:** 500 Rin cho ng∆∞·ªùi th·∫Øng!\n\n' +
                '‚ö†Ô∏è **L∆∞u √Ω:** Nene ch·ªâ d√πng trong game, h·∫øt ti·ªÅn = thua!')
            .addFields({ name: 'Ch·ªß ph√≤ng', value: message.author.toString(), inline: false })
            .setColor('#0099FF');

        const joinButton = new ButtonBuilder()
            .setCustomId('tp_join')
            .setLabel('üéüÔ∏è Tham gia')
            .setStyle(ButtonStyle.Success);

        const startButton = new ButtonBuilder()
            .setCustomId('tp_start')
            .setLabel('üöÄ B·∫Øt ƒë·∫ßu')
            .setStyle(ButtonStyle.Danger);

        const row = new ActionRowBuilder().addComponents(joinButton, startButton);
        const gameMessage = await message.reply({ embeds: [embed], components: [row] });

        // Collector for interactions
        const collector = gameMessage.createMessageComponentCollector({ time: 300000 });

        collector.on('collect', async (interaction) => {
            await this.handleInteraction(interaction);
        });

        collector.on('end', () => {
            if (rooms.has(channelId) && !rooms.get(channelId).started) {
                rooms.delete(channelId);
            }
        });
    },

    async handleInteraction(interaction) {
        const channelId = interaction.channel.id;
        const room = rooms.get(channelId);

        if (!room) {
            try {
                await interaction.reply({ content: '‚ùå Ph√≤ng kh√¥ng t·ªìn t·∫°i!', ephemeral: true });
            } catch {}
            return;
        }

        if (interaction.customId === 'tp_join') {
            if (room.started) {
                try {
                    await interaction.reply({ content: '‚ùå Game ƒë√£ b·∫Øt ƒë·∫ßu, kh√¥ng th·ªÉ tham gia!', ephemeral: true });
                } catch {}
                return;
            }

            if (interaction.user.id in room.players) {
                try {
                    await interaction.reply({ content: '‚ùå B·∫°n ƒë√£ tham gia r·ªìi!', ephemeral: true });
                } catch {}
                return;
            }

            // Ki·ªÉm tra t·ªëi ƒëa 8 ng∆∞·ªùi ch∆°i
            if (Object.keys(room.players).length >= 8) {
                try {
                    await interaction.reply({ content: '‚ùå Ph√≤ng ƒë√£ ƒë·∫ßy! T·ªëi ƒëa 8 ng∆∞·ªùi ch∆°i.', ephemeral: true });
                } catch {}
                return;
            }

            // Ch·ªâ c·∫ßn ki·ªÉm tra Rin ƒë·ªÉ tham gia
            const userRin = await getUserRin(interaction.user.id);
            if (userRin < 100) {
                try {
                    await interaction.reply({ content: '‚ùå B·∫°n c·∫ßn 100 Rin ƒë·ªÉ tham gia!', ephemeral: true });
                } catch {}
                return;
            }

            // Tr·ª´ ph√≠ tham gia (Rin)
            await updateUserRin(interaction.user.id, -100);

            room.players[interaction.user.id] = {
                user: interaction.user,
                money: 2000, // B·∫Øt ƒë·∫ßu v·ªõi 2000 Nene trong game
                position: 0,
                inJail: false,
                properties: []
            };

            const embed = new EmbedBuilder()
                .setTitle('‚úÖ Tham gia th√†nh c√¥ng!')
                .setDescription(`${interaction.user.displayName} ƒë√£ tham gia game!\n\n` +
                    `üí∞ **Ph√≠ tham gia:** -100 Rin\n` +
                    `üíé **Ti·ªÅn kh·ªüi ƒë·∫ßu:** 2000 Nene (trong game)`)
                .setColor('#00FF00');

            try {
                await interaction.reply({ embeds: [embed] });
            } catch {}
            return;

        } else if (interaction.customId === 'tp_start') {
            if (room.started) {
                try {
                    await interaction.reply({ content: '‚ùå Game ƒë√£ b·∫Øt ƒë·∫ßu r·ªìi!', ephemeral: true });
                } catch {}
                return;
            }

            if (interaction.user.id !== room.host.id) {
                try {
                    await interaction.reply({ content: '‚õî Ch·ªâ ch·ªß ph√≤ng ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu!', ephemeral: true });
                } catch {}
                return;
            }

            if (Object.keys(room.players).length < 2) {
                try {
                    await interaction.reply({ content: '‚ùå C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu!', ephemeral: true });
                } catch {}
                return;
            }

            room.started = true;
            room.turnOrder = Object.keys(room.players);

            const embed = new EmbedBuilder()
                .setTitle('üé≤ C·ªú T·ª∂ PH√ö B·∫ÆT ƒê·∫¶U!')
                .setDescription('Game ƒë√£ kh·ªüi ƒë·ªông! M·ªçi ng∆∞·ªùi b·∫Øt ƒë·∫ßu v·ªõi 2000 Nene!\n\n' +
                    'üèÜ **Ng∆∞·ªùi th·∫Øng s·∫Ω nh·∫≠n 500 Rin!**\n' +
                    'üí∏ **H·∫øt Nene = Thua cu·ªôc!**')
                .setColor('#0099FF');

            try {
                await interaction.reply({ embeds: [embed] });
            } catch {}

            // Start status tracking
            const statusEmbed = new EmbedBuilder()
                .setDescription(createBoardStatus(channelId))
                .setColor('#FFD700');
            try {
                room.statusMessage = await interaction.followUp({ embeds: [statusEmbed] });
            } catch {}

            // Start first turn
            await nextTurn(interaction.channel, channelId);
            return;

        } else if (interaction.customId.startsWith('roll_dice_')) {
            const playerId = interaction.customId.split('_')[2];
            if (!room.started) {
                try {
                    await interaction.reply({ content: '‚ùå Game ch∆∞a b·∫Øt ƒë·∫ßu!', ephemeral: true });
                } catch {}
                return;
            }
            if (interaction.user.id !== playerId) {
                try {
                    await interaction.reply({ content: '‚õî Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!', ephemeral: true });
                } catch {}
                return;
            }
            if (room.turnOrder[room.currentTurn] !== playerId) {
                try {
                    await interaction.reply({ content: '‚õî Ch∆∞a ƒë·∫øn l∆∞·ª£t c·ªßa b·∫°n!', ephemeral: true });
                } catch {}
                return;
            }
            const dice1 = rollDice();
            const dice2 = rollDice();
            const total = dice1 + dice2;
            const player = room.players[playerId];
            player.position = (player.position + total) % BOARD.length;
            // Pass start bonus
            if (player.position + total >= BOARD.length) {
                player.money += 200;
            }
            const embed = new EmbedBuilder()
                .setTitle('üé≤ K·∫øt qu·∫£ tung x√∫c x·∫Øc!')
                .setDescription(`${interaction.user.displayName} tung ƒë∆∞·ª£c: ${dice1} + ${dice2} = ${total}`)
                .addFields(
                    { name: 'V·ªã tr√≠ m·ªõi', value: BOARD[player.position].name, inline: false }
                )
                .setColor('#0099FF');
            try {
                await interaction.reply({ embeds: [embed] });
            } catch {}
            // Handle current position
            const needsWait = await handleProperty(interaction.channel, channelId, playerId);
            if (!needsWait) {
                setTimeout(() => nextTurn(interaction.channel, channelId), 2000);
            }
            return;
        } else if (interaction.customId.startsWith('buy_property_')) {
            const playerId = interaction.customId.split('_')[2];
            if (interaction.user.id !== playerId) {
                try {
                    await interaction.reply({ content: '‚õî Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!', ephemeral: true });
                } catch {}
                return;
            }
            const player = room.players[playerId];
            const position = BOARD[player.position];
            player.money -= position.price;
            room.properties[player.position] = playerId;
            const embed = new EmbedBuilder()
                .setTitle('üè† Mua ƒë·∫•t th√†nh c√¥ng!')
                .setDescription(`${interaction.user.displayName} ƒë√£ mua **${position.name}** v·ªõi gi√° ${position.price} Nene!`)
                .setColor('#00FF00');
            try {
                await interaction.reply({ embeds: [embed] });
            } catch {}
            setTimeout(() => nextTurn(interaction.channel, channelId), 2000);
            return;
        } else if (interaction.customId.startsWith('skip_property_')) {
            const playerId = interaction.customId.split('_')[2];
            if (interaction.user.id !== playerId) {
                try {
                    await interaction.reply({ content: '‚õî Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!', ephemeral: true });
                } catch {}
                return;
            }
            const embed = new EmbedBuilder()
                .setTitle('‚ùå B·ªè qua mua ƒë·∫•t')
                .setDescription(`${interaction.user.displayName} ƒë√£ b·ªè qua c∆° h·ªôi mua ƒë·∫•t!`)
                .setColor('#FF0000');
            try {
                await interaction.reply({ embeds: [embed] });
            } catch {}
            setTimeout(() => nextTurn(interaction.channel, channelId), 1000);
            return;
        }
    }
};