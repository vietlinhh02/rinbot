const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

function getCardString(card) {
    const suits = { 'hearts': '‚ô•Ô∏è', 'diamonds': '‚ô¶Ô∏è', 'clubs': '‚ô£Ô∏è', 'spades': '‚ô†Ô∏è' };
    const values = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };
    
    return `${values[card.value]}${suits[card.suit]}`;
}

function calculatePoints(cards) {
    let points = 0;
    let aces = 0;
    
    for (const card of cards) {
        if (card.value >= 11 && card.value <= 13) { // J, Q, K
            points += 10;
        } else if (card.value === 14) { // A
            points += 11;
            aces++;
        } else {
            points += card.value;
        }
    }
    
    // Adjust for aces
    while (points > 21 && aces > 0) {
        points -= 10;
        aces--;
    }
    
    return points;
}

function checkSpecialHand(cards) {
    if (cards.length === 2) {
        const values = cards.map(card => card.value);
        if (values.includes(14) && [10, 11, 12, 13].some(v => values.includes(v))) {
            return "X√¨ D√°ch";
        }
        if (values[0] === 14 && values[1] === 14) {
            return "X√¨ B√†n";
        }
    }
    
    if (cards.length === 5 && calculatePoints(cards) <= 21) {
        return "Ng≈© Linh";
    }
    
    return null;
}

// Action View class
class ActionView {
    static create(isHost) {
        const viewButton = new ButtonBuilder()
            .setCustomId('view_cards')
            .setLabel('üëÄ Xem b√†i')
            .setStyle(ButtonStyle.Primary);

        const drawButton = new ButtonBuilder()
            .setCustomId('draw_card')
            .setLabel('üÉè K√©o b√†i')
            .setStyle(ButtonStyle.Success);

        const stopButton = new ButtonBuilder()
            .setCustomId('stop_turn')
            .setLabel('üõë D·∫±n b√†i')
            .setStyle(ButtonStyle.Secondary);

        return new ActionRowBuilder().addComponents(viewButton, drawButton, stopButton);
    }

    static async handleInteraction(interaction, channelId) {
        try {
            // Ki·ªÉm tra game t·ªìn t·∫°i
            const game = global.games[channelId];
            if (!game) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚ùå Kh√¥ng t√¨m th·∫•y game!', flags: 64 });
                }
                return;
            }

            // Ki·ªÉm tra game ƒë√£ b·∫Øt ƒë·∫ßu
            if (!game.started) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚ùå Game ch∆∞a b·∫Øt ƒë·∫ßu!', flags: 64 });
                }
                return;
            }

            const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
            
            // Ki·ªÉm tra l∆∞·ª£t
            if (interaction.user.id !== currentPlayerId) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚õî Ch∆∞a t·ªõi l∆∞·ª£t b·∫°n!', flags: 64 });
                }
                return;
            }
            
            const isHost = currentPlayerId === game.host.id;
            const cards = isHost ? game.hostCards : game.players[currentPlayerId].cards;
            
            if (interaction.customId === 'view_cards') {
                const points = calculatePoints(cards);
                const special = checkSpecialHand(cards);

                let msg = `B√†i: ${cards.map(getCardString).join(', ')} (${points} ƒëi·ªÉm)`;
                if (special) msg += ` - ${special}`;

                const embed = new EmbedBuilder()
                    .setTitle('üÉè B√†i c·ªßa b·∫°n')
                    .setDescription(msg)
                    .setColor('#0099FF');

                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ embeds: [embed], flags: 64 });
                }
            }

            else if (interaction.customId === 'draw_card') {
                if (cards.length >= 5) {
                    if (!interaction.replied && !interaction.deferred) {
                        return await interaction.reply({ content: '‚ùå B·∫°n ƒë√£ ƒë·ªß 5 l√°!', flags: 64 });
                    }
                    return;
                }

                const newCard = game.deck.pop();
                cards.push(newCard);

                const points = calculatePoints(cards);
                const special = checkSpecialHand(cards);

                let msg = `K√©o: **${getCardString(newCard)}**\nB√†i hi·ªán t·∫°i: ${cards.map(getCardString).join(', ')} (${points} ƒëi·ªÉm)`;
                if (special) msg += ` - **${special}**`;

                const embed = new EmbedBuilder()
                    .setTitle('üÉè K√©o b√†i')
                    .setDescription(msg)
                    .setColor('#0099FF');

                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ embeds: [embed], flags: 64 });
                }

                // T·ª± ƒë·ªông k·∫øt th√∫c n·∫øu qu·∫Øc n·∫∑ng
                if (points >= 28) {
                    setTimeout(async () => {
                        if (isHost) {
                            game.hostDone = true;
                            await endGameFromXjrin(interaction.channel, channelId);
                        } else {
                            game.players[currentPlayerId].done = true;
                            game.currentPlayerIndex++;
                            await startNextTurnFromXjrin(interaction.channel, channelId);
                        }
                    }, 2000);
                }
            }

            else if (interaction.customId === 'stop_turn') {
                if (isHost) {
                    game.hostDone = true;
                    const embed = new EmbedBuilder()
                        .setTitle('üè† Nh√† c√°i d·∫±n b√†i!')
                        .setDescription('ƒêang l·∫≠t b√†i v√† t·ªïng k·∫øt k·∫øt qu·∫£...')
                        .setColor('#0099FF');

                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed] });
                    }
                    
                    setTimeout(async () => {
                        await endGameFromXjrin(interaction.channel, channelId);
                    }, 1500);
                } else {
                    game.players[currentPlayerId].done = true;
                    game.currentPlayerIndex++;

                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ D·∫±n b√†i!')
                        .setDescription('B·∫°n ƒë√£ d·∫±n b√†i th√†nh c√¥ng!')
                        .setColor('#00FF00');

                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed], flags: 64 });
                    }
                    
                    setTimeout(async () => {
                        await startNextTurnFromXjrin(interaction.channel, channelId);
                    }, 1500);
                }
            }
        } catch (error) {
            console.error('Error in ActionView.handleInteraction:', error);
        }
    }
}

async function startNextTurnFromXjrin(channel, channelId) {
    const game = global.games[channelId];
    if (!game) return;

    if (game.currentPlayerIndex >= game.playerOrder.length) {
        return await endGameFromXjrin(channel, channelId);
    }

    const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
    const isHost = currentPlayerId === game.host.id;
    const currentPlayer = isHost ? game.host : game.players[currentPlayerId].user;

    const embed = new EmbedBuilder()
        .setTitle(isHost ? 'üè† L∆∞·ª£t nh√† c√°i!' : 'üéØ L∆∞·ª£t c·ªßa b·∫°n!')
        .setDescription(`${currentPlayer}, g√µ \`,xjrin\` ƒë·ªÉ xem b√†i v√† h√†nh ƒë·ªông!`)
        .setColor('#0099FF');

    await channel.send({ embeds: [embed] });
}

async function endGameFromXjrin(channel, channelId) {
    // S·ª≠ d·ª•ng endGame t·ª´ xjgo.js
    const xjgoCommand = require('./xjgo');
    if (xjgoCommand.endGame) {
        await xjgoCommand.endGame(channel, channelId);
        return;
    }
    
    // Fallback implementation n·∫øu kh√¥ng c√≥ function
    const game = global.games[channelId];
    if (!game) return;

    const { updateUserRin } = require('../../utils/database');
    const { calculatePoints, checkSpecialHand } = require('./xjgo');

    const hostPoints = calculatePoints(game.hostCards);
    const hostSpecial = checkSpecialHand(game.hostCards);

    const embed = new EmbedBuilder()
        .setTitle('üé≤ K·∫æT QU·∫¢ X√å D√ÅCH')
        .setColor('#0099FF');

    let hostMsg = `Nh√† c√°i: ${game.hostCards.map(getCardString).join(', ')} (${hostPoints} ƒëi·ªÉm)`;
    if (hostSpecial) hostMsg += ` - ${hostSpecial}`;
    
    embed.addFields({ name: 'üè† Nh√† c√°i', value: hostMsg, inline: false });

    let totalHostWinnings = 0;
    let totalHostLosses = 0;

    for (const [pid, pdata] of Object.entries(game.players)) {
        const playerPoints = calculatePoints(pdata.cards);
        const playerSpecial = checkSpecialHand(pdata.cards);
        const bet = pdata.bet;
        
        let playerMsg = `${pdata.cards.map(getCardString).join(', ')} (${playerPoints} ƒëi·ªÉm)`;
        if (playerSpecial) playerMsg += ` - ${playerSpecial}`;
        
        let outcome = '';
        let playerWinAmount = 0;

        // √Åp d·ª•ng lu·∫≠t m·ªõi
        if (playerSpecial === "X√¨ B√†n") {
            playerWinAmount = bet + (bet * 3);
            totalHostLosses += bet * 3;
            outcome = `üéâ X√¨ B√†n ‚Äì Th·∫Øng +${bet * 3} Rin`;
        } else if (hostSpecial === "X√¨ B√†n") {
            totalHostWinnings += bet;
            outcome = `‚ùå Thua X√¨ B√†n nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
        } else if (playerSpecial === "Ng≈© Linh") {
            if (hostSpecial === "Ng≈© Linh") {
                playerWinAmount = bet;
                outcome = 'ü§ù H√≤a (c·∫£ hai Ng≈© Linh)';
            } else {
                playerWinAmount = bet + (bet * 2);
                totalHostLosses += bet * 2;
                outcome = `üéâ Ng≈© Linh ‚Äì Th·∫Øng +${bet * 2} Rin`;
            }
        } else if (hostSpecial === "Ng≈© Linh") {
            totalHostWinnings += bet;
            outcome = `‚ùå Thua Ng≈© Linh nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
        } else if (playerSpecial === "X√¨ D√°ch") {
            if (hostSpecial === "X√¨ D√°ch") {
                playerWinAmount = bet;
                outcome = `ü§ù H√≤a (c√πng X√¨ D√°ch)`;
            } else {
                playerWinAmount = bet + (bet * 2);
                totalHostLosses += bet * 2;
                outcome = `üéâ X√¨ D√°ch ‚Äì Th·∫Øng +${bet * 2} Rin`;
            }
        } else if (hostSpecial === "X√¨ D√°ch") {
            totalHostWinnings += bet;
            outcome = `‚ùå Thua X√¨ D√°ch nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
        } else {
            // Logic ƒëi·ªÉm th∆∞·ªùng v·ªõi lu·∫≠t m·ªõi
            if (playerPoints >= 28) {
                totalHostWinnings += bet * 2;
                outcome = `üí• Qu·∫Øc n·∫∑ng (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
            } else if (playerPoints >= 22 && playerPoints <= 27 && hostPoints >= 22 && hostPoints <= 27) {
                playerWinAmount = bet;
                outcome = `ü§ù H√≤a (c·∫£ hai qu·∫Øc nh·∫π: ${playerPoints} vs ${hostPoints})`;
            } else if (playerPoints >= 22 && playerPoints <= 27) {
                if (hostPoints > 21) {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (player qu·∫Øc nh·∫π ${playerPoints}, nh√† c√°i qu·∫Øc ${hostPoints})`;
                } else {
                    totalHostWinnings += bet;
                    outcome = `‚ùå Qu·∫Øc nh·∫π (${playerPoints}) ‚Äì M·∫•t ${bet} Rin`;
                }
            } else if (hostPoints >= 22 && hostPoints <= 27) {
                if (playerPoints > 21) {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (nh√† c√°i qu·∫Øc nh·∫π ${hostPoints}, player qu·∫Øc ${playerPoints})`;
                } else {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Nh√† c√°i qu·∫Øc nh·∫π ‚Äì Th·∫Øng +${bet} Rin`;
                }
            } else if (hostPoints >= 28) {
                playerWinAmount = bet + bet;
                totalHostLosses += bet;
                outcome = `‚úÖ Nh√† c√°i qu·∫Øc n·∫∑ng ‚Äì Th·∫Øng +${bet} Rin`;
            } else if (playerPoints < 16) {
                totalHostWinnings += bet * 2;
                outcome = `üë∂ Ch∆∞a ƒë·ªß tu·ªïi (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
            } else if (hostPoints < 16) {
                playerWinAmount = bet + bet;
                totalHostLosses += bet;
                outcome = `‚úÖ Nh√† c√°i ch∆∞a ƒë·ªß tu·ªïi ‚Äì Th·∫Øng +${bet} Rin`;
            } else if (playerPoints > hostPoints) {
                playerWinAmount = bet + bet;
                totalHostLosses += bet;
                outcome = `‚úÖ Th·∫Øng ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì Th·∫Øng +${bet} Rin`;
            } else if (playerPoints < hostPoints) {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì M·∫•t ${bet} Rin`;
            } else {
                playerWinAmount = bet;
                outcome = `ü§ù H√≤a ƒëi·ªÉm (${playerPoints})`;
            }
        }

        if (playerWinAmount > 0) {
            await updateUserRin(pdata.user.id, playerWinAmount);
        }

        embed.addFields({ 
            name: pdata.user.displayName, 
            value: `${playerMsg}\n${outcome}`, 
            inline: false 
        });
    }

    // C·∫≠p nh·∫≠t ti·ªÅn cho nh√† c√°i
    const hostNetWinnings = totalHostWinnings - totalHostLosses;
    if (hostNetWinnings > 0) {
        await updateUserRin(game.host.id, hostNetWinnings);
        embed.addFields({ 
            name: 'üí∞ Nh√† c√°i', 
            value: `üéâ Th·∫Øng r√≤ng: +${hostNetWinnings} Rin`, 
            inline: false 
        });
    } else if (hostNetWinnings < 0) {
        embed.addFields({ 
            name: 'üí∞ Nh√† c√°i', 
            value: `üí∏ Thua r√≤ng: ${hostNetWinnings} Rin`, 
            inline: false 
        });
    } else {
        embed.addFields({ 
            name: 'üí∞ Nh√† c√°i', 
            value: `ü§ù H√≤a v·ªën: 0 Rin`, 
            inline: false 
        });
    }

    await channel.send({ embeds: [embed] });
    delete global.games[channelId];
}

module.exports = {
    name: 'xjrin',
    description: 'R√∫t b√†i trong game X√¨ D√°ch',
    async execute(message, args) {
        try {
            const channelId = message.channel.id;
            const game = global.games[channelId];

            if (!game) {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå L·ªói!')
                    .setDescription('Kh√¥ng c√≥ b√†n n√†o!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            if (!game.started) {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå L·ªói!')
                    .setDescription('Ch∆∞a b·∫Øt ƒë·∫ßu tr·∫≠n!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
            if (message.author.id !== currentPlayerId) {
                const embed = new EmbedBuilder()
                    .setTitle('‚õî L·ªói!')
                    .setDescription('Ch∆∞a t·ªõi l∆∞·ª£t b·∫°n!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            const isHost = currentPlayerId === game.host.id;
            const actionView = ActionView.create(isHost);

            const embed = new EmbedBuilder()
                .setTitle('üé¥ H√†nh ƒë·ªông')
                .setDescription(`${message.author} m·ªü giao di·ªán!`)
                .setColor('#0099FF');

            await message.reply({ embeds: [embed], components: [actionView] });

        } catch (error) {
            console.error('L·ªói xjrin:', error);
            await message.reply('‚ùå C√≥ l·ªói x·∫£y ra!');
        }
    },

    // Export ActionView ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng t·ª´ b√™n ngo√†i
    ActionView
}; 