const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

function getCardString(card) {
    const suits = { 'hearts': '‚ô•Ô∏è', 'diamonds': '‚ô¶Ô∏è', 'clubs': '‚ô£Ô∏è', 'spades': '‚ô†Ô∏è' };
    const values = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };
    
    return `${values[card.value]}${suits[card.suit]}`;
}

function calculatePoints(cards) {
    let points = 0;
    let aces = 0;
    
    for (const card of cards) {
        if (card.value >= 11 && card.value <= 13) { // J, Q, K
            points += 10;
        } else if (card.value === 14) { // A
            points += 11;
            aces++;
        } else {
            points += card.value;
        }
    }
    
    // Adjust for aces
    while (points > 21 && aces > 0) {
        points -= 10;
        aces--;
    }
    
    return points;
}

function checkSpecialHand(cards) {
    if (cards.length === 2) {
        const values = cards.map(card => card.value);
        if (values.includes(14) && [10, 11, 12, 13].some(v => values.includes(v))) {
            return "X√¨ D√°ch";
        }
        if (values[0] === 14 && values[1] === 14) {
            return "X√¨ B√†n";
        }
    }
    
    if (cards.length === 5 && calculatePoints(cards) <= 21) {
        return "Ng≈© Linh";
    }
    
    return null;
}

// Action View class
class ActionView {
    static create(isHost) {
        const viewButton = new ButtonBuilder()
            .setCustomId('view_cards')
            .setLabel('üëÄ Xem b√†i')
            .setStyle(ButtonStyle.Primary);

        const drawButton = new ButtonBuilder()
            .setCustomId('draw_card')
            .setLabel('üÉè K√©o b√†i')
            .setStyle(ButtonStyle.Success);

        const stopButton = new ButtonBuilder()
            .setCustomId('stop_turn')
            .setLabel('üõë D·∫±n b√†i')
            .setStyle(ButtonStyle.Secondary);

        return new ActionRowBuilder().addComponents(viewButton, drawButton, stopButton);
    }

    static async handleInteraction(interaction, channelId) {
        try {
            // Ki·ªÉm tra game t·ªìn t·∫°i
            const game = global.games[channelId];
            if (!game) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚ùå Kh√¥ng t√¨m th·∫•y game!', flags: 64 });
                }
                return;
            }

            // Ki·ªÉm tra game ƒë√£ b·∫Øt ƒë·∫ßu
            if (!game.started) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚ùå Game ch∆∞a b·∫Øt ƒë·∫ßu!', flags: 64 });
                }
                return;
            }

            const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
            
            // Ki·ªÉm tra l∆∞·ª£t
            if (interaction.user.id !== currentPlayerId) {
                if (!interaction.replied && !interaction.deferred) {
                    return await interaction.reply({ content: '‚õî Ch∆∞a t·ªõi l∆∞·ª£t b·∫°n!', flags: 64 });
                }
                return;
            }
            
            const isHost = currentPlayerId === game.host.id;
            const cards = isHost ? game.hostCards : game.players[currentPlayerId].cards;
            
            if (interaction.customId === 'view_cards') {
                const points = calculatePoints(cards);
                const special = checkSpecialHand(cards);

                let msg = `B√†i: ${cards.map(getCardString).join(', ')} (${points} ƒëi·ªÉm)`;
                if (special) msg += ` - ${special}`;

                const embed = new EmbedBuilder()
                    .setTitle('üÉè B√†i c·ªßa b·∫°n')
                    .setDescription(msg)
                    .setColor('#0099FF');

                // T·∫°o h√¨nh ·∫£nh cho b√†i hi·ªán t·∫°i
                try {
                    const imageUtils = require('../../utils/imageUtils');
                    if (imageUtils.isCanvasAvailable()) {
                        const path = require('path');
                        const { AttachmentBuilder } = require('discord.js');
                        
                        const imagePath = path.join(__dirname, `../../temp/xjrin_view_${interaction.user.id}_${Date.now()}.png`);
                        
                        // T·∫°o temp directory
                        require('fs').mkdirSync(path.dirname(imagePath), { recursive: true });
                        
                        // Chu·∫©n b·ªã data: hi·ªÉn th·ªã b√†i dealer √∫p v√† ch·ªâ b√†i c·ªßa ng∆∞·ªùi n√†y m·∫∑t tr∆∞·ªõc
                        const dealerHand = game.hostCards.map(card => ({ ...card, down: true })); // Dealer v·∫´n √∫p
                        const playerHands = [{
                            name: interaction.user.displayName,
                            hand: cards // Ch·ªâ b√†i c·ªßa user n√†y m·∫∑t tr∆∞·ªõc
                        }];
                        
                        await imageUtils.createBlackjackTable(dealerHand, playerHands, imagePath);
                        
                        const attachment = new AttachmentBuilder(imagePath, { name: 'my_cards.png' });
                        embed.setImage('attachment://my_cards.png');
                        
                        if (!interaction.replied && !interaction.deferred) {
                            await interaction.reply({ embeds: [embed], files: [attachment], flags: 64 });
                        }
                        
                        // Cleanup sau 5 gi√¢y
                        setTimeout(() => {
                            imageUtils.cleanupTempFiles([imagePath]);
                        }, 5000);
                    } else {
                        // Text fallback
                        if (!interaction.replied && !interaction.deferred) {
                            await interaction.reply({ embeds: [embed], flags: 64 });
                        }
                    }
                } catch (error) {
                    console.error('L·ªói t·∫°o h√¨nh ·∫£nh view cards:', error);
                    // Text fallback
                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed], flags: 64 });
                    }
                }
            }

            else if (interaction.customId === 'draw_card') {
                if (cards.length >= 5) {
                    if (!interaction.replied && !interaction.deferred) {
                        return await interaction.reply({ content: '‚ùå B·∫°n ƒë√£ ƒë·ªß 5 l√°!', flags: 64 });
                    }
                    return;
                }

                const newCard = game.deck.pop();
                cards.push(newCard);

                const points = calculatePoints(cards);
                const special = checkSpecialHand(cards);

                let msg = `K√©o: **${getCardString(newCard)}**\nB√†i hi·ªán t·∫°i: ${cards.map(getCardString).join(', ')} (${points} ƒëi·ªÉm)`;
                if (special) msg += ` - **${special}**`;

                const embed = new EmbedBuilder()
                    .setTitle('üÉè K√©o b√†i')
                    .setDescription(msg)
                    .setColor('#0099FF');

                // T·∫°o h√¨nh ·∫£nh v·ªõi b√†i m·ªõi
                try {
                    const imageUtils = require('../../utils/imageUtils');
                    if (imageUtils.isCanvasAvailable()) {
                        const path = require('path');
                        const { AttachmentBuilder } = require('discord.js');
                        
                        const imagePath = path.join(__dirname, `../../temp/xjrin_draw_${interaction.user.id}_${Date.now()}.png`);
                        
                        // T·∫°o temp directory
                        require('fs').mkdirSync(path.dirname(imagePath), { recursive: true });
                        
                        // Chu·∫©n b·ªã data: hi·ªÉn th·ªã b√†i dealer √∫p v√† b√†i c·ªßa ng∆∞·ªùi ch∆°i v·ªõi card m·ªõi
                        const dealerHand = game.hostCards.map(card => ({ ...card, down: true })); // Dealer v·∫´n √∫p
                        const playerHands = [{
                            name: interaction.user.displayName,
                            hand: cards // T·∫•t c·∫£ b√†i bao g·ªìm card m·ªõi, m·∫∑t tr∆∞·ªõc
                        }];
                        
                        await imageUtils.createBlackjackTable(dealerHand, playerHands, imagePath);
                        
                        const attachment = new AttachmentBuilder(imagePath, { name: 'draw_card.png' });
                        embed.setImage('attachment://draw_card.png');
                        
                        if (!interaction.replied && !interaction.deferred) {
                            await interaction.reply({ embeds: [embed], files: [attachment], flags: 64 });
                        }
                        
                        // Cleanup sau 5 gi√¢y
                        setTimeout(() => {
                            imageUtils.cleanupTempFiles([imagePath]);
                        }, 5000);
                    } else {
                        // Text fallback
                        if (!interaction.replied && !interaction.deferred) {
                            await interaction.reply({ embeds: [embed], flags: 64 });
                        }
                    }
                } catch (error) {
                    console.error('L·ªói t·∫°o h√¨nh ·∫£nh draw card:', error);
                    // Text fallback
                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed], flags: 64 });
                    }
                }

                // T·ª± ƒë·ªông k·∫øt th√∫c n·∫øu qu·∫Øc n·∫∑ng
                if (points >= 28) {
                    setTimeout(async () => {
                        if (isHost) {
                            game.hostDone = true;
                            await endGameFromXjrin(interaction.channel, channelId);
                        } else {
                            game.players[currentPlayerId].done = true;
                            game.currentPlayerIndex++;
                            await startNextTurnFromXjrin(interaction.channel, channelId);
                        }
                    }, 2000);
                }
            }

            else if (interaction.customId === 'stop_turn') {
                if (isHost) {
                    game.hostDone = true;
                    const embed = new EmbedBuilder()
                        .setTitle('üè† Nh√† c√°i d·∫±n b√†i!')
                        .setDescription('ƒêang l·∫≠t b√†i v√† t·ªïng k·∫øt k·∫øt qu·∫£...')
                        .setColor('#0099FF');

                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed] });
                    }
                    
                    setTimeout(async () => {
                        try {
                            await endGameFromXjrin(interaction.channel, channelId);
                        } catch (error) {
                            console.error('L·ªói k·∫øt th√∫c game:', error);
                        }
                    }, 1500);
                } else {
                    game.players[currentPlayerId].done = true;
                    game.currentPlayerIndex++;

                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ D·∫±n b√†i!')
                        .setDescription('B·∫°n ƒë√£ d·∫±n b√†i th√†nh c√¥ng!')
                        .setColor('#00FF00');

                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ embeds: [embed], flags: 64 });
                    }
                    
                    setTimeout(async () => {
                        try {
                            await startNextTurnFromXjrin(interaction.channel, channelId);
                        } catch (error) {
                            console.error('L·ªói start next turn:', error);
                        }
                    }, 1500);
                }
            }
        } catch (error) {
            console.error('Error in ActionView.handleInteraction:', error);
        }
    }
}

async function startNextTurnFromXjrin(channel, channelId) {
    const game = global.games[channelId];
    if (!game) return;

    if (game.currentPlayerIndex >= game.playerOrder.length) {
        return await endGameFromXjrin(channel, channelId);
    }

    const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
    const isHost = currentPlayerId === game.host.id;
    const currentPlayer = isHost ? game.host : game.players[currentPlayerId].user;

    const embed = new EmbedBuilder()
        .setTitle(isHost ? 'üè† L∆∞·ª£t nh√† c√°i!' : 'üéØ L∆∞·ª£t c·ªßa b·∫°n!')
        .setDescription(`${currentPlayer}, g√µ \`,xjrin\` ƒë·ªÉ xem b√†i v√† h√†nh ƒë·ªông!`)
        .setColor('#0099FF');

    await channel.send({ embeds: [embed] });
}

async function endGameFromXjrin(channel, channelId) {
    console.log('üèÅ === B·∫ÆT ƒê·∫¶U END GAME (XJRIN) ===');
    const game = global.games[channelId];
    if (!game) {
        console.log('‚ùå Kh√¥ng t√¨m th·∫•y game khi endGame (xjrin)');
        return;
    }

    console.log('üìä Game stats (xjrin):');
    console.log('  - Host:', game.host.displayName);
    console.log('  - Players:', Object.keys(game.players).length);
    console.log('  - Host cards:', game.hostCards?.length || 0);

    const { updateUserRin } = require('../../utils/database');
    const imageUtils = require('../../utils/imageUtils');
    const { AttachmentBuilder } = require('discord.js');
    const path = require('path');

    const hostPoints = calculatePoints(game.hostCards);
    const hostSpecial = checkSpecialHand(game.hostCards);
    console.log('üè† Host:', hostPoints, 'ƒëi·ªÉm', hostSpecial ? `(${hostSpecial})` : '');

    const tempFiles = [];
    
    try {
        // Ki·ªÉm tra Canvas availability
        if (!imageUtils.isCanvasAvailable()) {
            console.log('‚ùå Canvas kh√¥ng kh·∫£ d·ª•ng - fallback text (xjrin)');
            throw new Error('Canvas kh√¥ng kh·∫£ d·ª•ng');
        }
        
        console.log('üñºÔ∏è T·∫°o h√¨nh ·∫£nh k·∫øt qu·∫£ game (xjrin)...');
        
        // Chu·∫©n b·ªã data cho h√¨nh ·∫£nh k·∫øt qu·∫£ - T·∫§T C·∫¢ b√†i FACE-UP
        const dealerHand = game.hostCards || [];
        const playerHands = Object.values(game.players).map(p => ({
            name: p.user.displayName,
            hand: p.cards || []
        }));
        
        console.log('üè† Dealer hand:', dealerHand.length, 'cards');
        console.log('üîç First dealer card:', JSON.stringify(dealerHand[0]));
        console.log('üë• Player hands:', playerHands.length, 'players');
        if (playerHands[0]) {
            console.log('üîç First player card:', JSON.stringify(playerHands[0].hand[0]));
        }

        // Validate card data v√† force FACE-UP cho k·∫øt qu·∫£
        const validateCard = (card) => {
            return card && 
                   typeof card.suit === 'string' && 
                   typeof card.value === 'number' &&
                   ['hearts', 'diamonds', 'clubs', 'spades'].includes(card.suit) &&
                   card.value >= 2 && card.value <= 14;
        };
        
        const preserveCardProperties = (card) => {
            return {
                suit: card.suit,
                value: card.value,
                hidden: card.hidden || false,
                down: false // Force face-up cho k·∫øt qu·∫£
            };
        };

        // Filter v√† ensure t·∫•t c·∫£ b√†i FACE-UP khi k·∫øt th√∫c game
        const validDealerHand = dealerHand
            .filter(validateCard)
            .map(preserveCardProperties);
        const validPlayerHands = playerHands.map(p => ({
            name: p.name,
            hand: p.hand
                .filter(validateCard)
                .map(preserveCardProperties)
        }));

        console.log('üîç Result dealer first card:', JSON.stringify(validDealerHand[0]));
        if (validPlayerHands[0] && validPlayerHands[0].hand[0]) {
            console.log('üîç Result player first card:', JSON.stringify(validPlayerHands[0].hand[0]));
        }

        // T·∫°o GIF animation m·ªü b√†i cho k·∫øt qu·∫£
        const gifPath = path.join(__dirname, `../../temp/xidach_result_${Date.now()}.gif`);
        tempFiles.push(gifPath);
        
        // T·∫°o temp directory n·∫øu ch∆∞a c√≥
        const tempDir = path.dirname(gifPath);
        require('fs').mkdirSync(tempDir, { recursive: true });
        
        console.log('üé¨ T·∫°o GIF animation m·ªü b√†i k·∫øt qu·∫£ (xjrin)...');
        await imageUtils.createBlackjackGIF(validDealerHand, validPlayerHands, gifPath);
        console.log('‚úÖ GIF k·∫øt qu·∫£ t·∫°o th√†nh c√¥ng (xjrin):', gifPath);
        
        const attachment = new AttachmentBuilder(gifPath, { name: 'xidach_result.gif' });
        
        const embed = new EmbedBuilder()
            .setTitle('üé≤ K·∫æT QU·∫¢ X√å D√ÅCH')
            .setDescription('üÉè **T·∫•t c·∫£ b√†i ƒë√£ ƒë∆∞·ª£c m·ªü!**')
            .setColor('#0099FF')
            .setImage('attachment://xidach_result.gif');

        let hostMsg = `${game.hostCards.map(getCardString).join(', ')} (${hostPoints} ƒëi·ªÉm)`;
        if (hostSpecial) hostMsg += ` - ${hostSpecial}`;
        
        embed.addFields({ name: 'üè† Nh√† c√°i', value: hostMsg, inline: false });

        let totalHostWinnings = 0;
        let totalHostLosses = 0;

        for (const [pid, pdata] of Object.entries(game.players)) {
            const playerPoints = calculatePoints(pdata.cards);
            const playerSpecial = checkSpecialHand(pdata.cards);
            const bet = pdata.bet;
            
            let playerMsg = `${pdata.cards.map(getCardString).join(', ')} (${playerPoints} ƒëi·ªÉm)`;
            if (playerSpecial) playerMsg += ` - ${playerSpecial}`;
            
            let outcome = '';
            let playerWinAmount = 0;

            // √Åp d·ª•ng lu·∫≠t m·ªõi
            if (playerSpecial === "X√¨ B√†n") {
                playerWinAmount = bet + (bet * 3);
                totalHostLosses += bet * 3;
                outcome = `üéâ X√¨ B√†n ‚Äì Th·∫Øng +${bet * 3} Rin`;
            } else if (hostSpecial === "X√¨ B√†n") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua X√¨ B√†n nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else if (playerSpecial === "Ng≈© Linh") {
                if (hostSpecial === "Ng≈© Linh") {
                    playerWinAmount = bet;
                    outcome = 'ü§ù H√≤a (c·∫£ hai Ng≈© Linh)';
                } else {
                    playerWinAmount = bet + (bet * 2);
                    totalHostLosses += bet * 2;
                    outcome = `üéâ Ng≈© Linh ‚Äì Th·∫Øng +${bet * 2} Rin`;
                }
            } else if (hostSpecial === "Ng≈© Linh") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua Ng≈© Linh nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else if (playerSpecial === "X√¨ D√°ch") {
                if (hostSpecial === "X√¨ D√°ch") {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (c√πng X√¨ D√°ch)`;
                } else {
                    playerWinAmount = bet + (bet * 2);
                    totalHostLosses += bet * 2;
                    outcome = `üéâ X√¨ D√°ch ‚Äì Th·∫Øng +${bet * 2} Rin`;
                }
            } else if (hostSpecial === "X√¨ D√°ch") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua X√¨ D√°ch nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else {
                // Logic ƒëi·ªÉm th∆∞·ªùng v·ªõi lu·∫≠t m·ªõi
                if (playerPoints >= 28) {
                    totalHostWinnings += bet * 2;
                    outcome = `üí• Qu·∫Øc n·∫∑ng (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
                } else if (playerPoints >= 22 && playerPoints <= 27 && hostPoints >= 22 && hostPoints <= 27) {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (c·∫£ hai qu·∫Øc nh·∫π: ${playerPoints} vs ${hostPoints})`;
                } else if (playerPoints >= 22 && playerPoints <= 27) {
                    if (hostPoints > 21) {
                        playerWinAmount = bet;
                        outcome = `ü§ù H√≤a (player qu·∫Øc nh·∫π ${playerPoints}, nh√† c√°i qu·∫Øc ${hostPoints})`;
                    } else {
                        totalHostWinnings += bet;
                        outcome = `‚ùå Qu·∫Øc nh·∫π (${playerPoints}) ‚Äì M·∫•t ${bet} Rin`;
                    }
                } else if (hostPoints >= 22 && hostPoints <= 27) {
                    if (playerPoints > 21) {
                        playerWinAmount = bet;
                        outcome = `ü§ù H√≤a (nh√† c√°i qu·∫Øc nh·∫π ${hostPoints}, player qu·∫Øc ${playerPoints})`;
                    } else {
                        playerWinAmount = bet + bet;
                        totalHostLosses += bet;
                        outcome = `‚úÖ Nh√† c√°i qu·∫Øc nh·∫π ‚Äì Th·∫Øng +${bet} Rin`;
                    }
                } else if (hostPoints >= 28) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Nh√† c√°i qu·∫Øc n·∫∑ng ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints < 16) {
                    totalHostWinnings += bet * 2;
                    outcome = `üë∂ Ch∆∞a ƒë·ªß tu·ªïi (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
                } else if (hostPoints < 16) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Nh√† c√°i ch∆∞a ƒë·ªß tu·ªïi ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints > hostPoints) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Th·∫Øng ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints < hostPoints) {
                    totalHostWinnings += bet;
                    outcome = `‚ùå Thua ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì M·∫•t ${bet} Rin`;
                } else {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a ƒëi·ªÉm (${playerPoints})`;
                }
            }

            if (playerWinAmount > 0) {
                await updateUserRin(pdata.user.id, playerWinAmount);
            }

            embed.addFields({ 
                name: pdata.user.displayName, 
                value: `${playerMsg}\n${outcome}`, 
                inline: false 
            });
        }

        // C·∫≠p nh·∫≠t ti·ªÅn cho nh√† c√°i
        const hostNetWinnings = totalHostWinnings - totalHostLosses;
        if (hostNetWinnings > 0) {
            await updateUserRin(game.host.id, hostNetWinnings);
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `üéâ Th·∫Øng r√≤ng: +${hostNetWinnings} Rin`, 
                inline: false 
            });
        } else if (hostNetWinnings < 0) {
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `üí∏ Thua r√≤ng: ${hostNetWinnings} Rin`, 
                inline: false 
            });
        } else {
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `ü§ù H√≤a v·ªën: 0 Rin`, 
                inline: false 
            });
        }

        await channel.send({ 
            embeds: [embed], 
            files: [attachment]
        });

        // Cleanup temp files sau 10 gi√¢y
        setTimeout(() => {
            imageUtils.cleanupTempFiles(tempFiles);
        }, 10000);

    } catch (error) {
        console.error('L·ªói t·∫°o h√¨nh ·∫£nh k·∫øt qu·∫£ (xjrin):', error);
        // Fallback v·ªÅ text display
        const embed = new EmbedBuilder()
            .setTitle('üé≤ K·∫æT QU·∫¢ X√å D√ÅCH')
            .setColor('#0099FF');

        let hostMsg = `${game.hostCards.map(getCardString).join(', ')} (${hostPoints} ƒëi·ªÉm)`;
        if (hostSpecial) hostMsg += ` - ${hostSpecial}`;
        
        embed.addFields({ name: 'üè† Nh√† c√°i', value: hostMsg, inline: false });

        let totalHostWinnings = 0;
        let totalHostLosses = 0;

        for (const [pid, pdata] of Object.entries(game.players)) {
            const playerPoints = calculatePoints(pdata.cards);
            const playerSpecial = checkSpecialHand(pdata.cards);
            const bet = pdata.bet;
            
            let playerMsg = `${pdata.cards.map(getCardString).join(', ')} (${playerPoints} ƒëi·ªÉm)`;
            if (playerSpecial) playerMsg += ` - ${playerSpecial}`;
            
            let outcome = '';
            let playerWinAmount = 0;

            // √Åp d·ª•ng lu·∫≠t m·ªõi (copy t·ª´ ph·∫ßn tr√™n)
            if (playerSpecial === "X√¨ B√†n") {
                playerWinAmount = bet + (bet * 3);
                totalHostLosses += bet * 3;
                outcome = `üéâ X√¨ B√†n ‚Äì Th·∫Øng +${bet * 3} Rin`;
            } else if (hostSpecial === "X√¨ B√†n") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua X√¨ B√†n nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else if (playerSpecial === "Ng≈© Linh") {
                if (hostSpecial === "Ng≈© Linh") {
                    playerWinAmount = bet;
                    outcome = 'ü§ù H√≤a (c·∫£ hai Ng≈© Linh)';
                } else {
                    playerWinAmount = bet + (bet * 2);
                    totalHostLosses += bet * 2;
                    outcome = `üéâ Ng≈© Linh ‚Äì Th·∫Øng +${bet * 2} Rin`;
                }
            } else if (hostSpecial === "Ng≈© Linh") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua Ng≈© Linh nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else if (playerSpecial === "X√¨ D√°ch") {
                if (hostSpecial === "X√¨ D√°ch") {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (c√πng X√¨ D√°ch)`;
                } else {
                    playerWinAmount = bet + (bet * 2);
                    totalHostLosses += bet * 2;
                    outcome = `üéâ X√¨ D√°ch ‚Äì Th·∫Øng +${bet * 2} Rin`;
                }
            } else if (hostSpecial === "X√¨ D√°ch") {
                totalHostWinnings += bet;
                outcome = `‚ùå Thua X√¨ D√°ch nh√† c√°i ‚Äì M·∫•t ${bet} Rin`;
            } else {
                // Logic ƒëi·ªÉm th∆∞·ªùng
                if (playerPoints >= 28) {
                    totalHostWinnings += bet * 2;
                    outcome = `üí• Qu·∫Øc n·∫∑ng (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
                } else if (playerPoints >= 22 && playerPoints <= 27 && hostPoints >= 22 && hostPoints <= 27) {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a (c·∫£ hai qu·∫Øc nh·∫π: ${playerPoints} vs ${hostPoints})`;
                } else if (playerPoints >= 22 && playerPoints <= 27) {
                    if (hostPoints > 21) {
                        playerWinAmount = bet;
                        outcome = `ü§ù H√≤a (player qu·∫Øc nh·∫π ${playerPoints}, nh√† c√°i qu·∫Øc ${hostPoints})`;
                    } else {
                        totalHostWinnings += bet;
                        outcome = `‚ùå Qu·∫Øc nh·∫π (${playerPoints}) ‚Äì M·∫•t ${bet} Rin`;
                    }
                } else if (hostPoints >= 22 && hostPoints <= 27) {
                    if (playerPoints > 21) {
                        playerWinAmount = bet;
                        outcome = `ü§ù H√≤a (nh√† c√°i qu·∫Øc nh·∫π ${hostPoints}, player qu·∫Øc ${playerPoints})`;
                    } else {
                        playerWinAmount = bet + bet;
                        totalHostLosses += bet;
                        outcome = `‚úÖ Nh√† c√°i qu·∫Øc nh·∫π ‚Äì Th·∫Øng +${bet} Rin`;
                    }
                } else if (hostPoints >= 28) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Nh√† c√°i qu·∫Øc n·∫∑ng ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints < 16) {
                    totalHostWinnings += bet * 2;
                    outcome = `üë∂ Ch∆∞a ƒë·ªß tu·ªïi (${playerPoints}) ‚Äì M·∫•t ${bet * 2} Rin`;
                } else if (hostPoints < 16) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Nh√† c√°i ch∆∞a ƒë·ªß tu·ªïi ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints > hostPoints) {
                    playerWinAmount = bet + bet;
                    totalHostLosses += bet;
                    outcome = `‚úÖ Th·∫Øng ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì Th·∫Øng +${bet} Rin`;
                } else if (playerPoints < hostPoints) {
                    totalHostWinnings += bet;
                    outcome = `‚ùå Thua ƒëi·ªÉm (${playerPoints} vs ${hostPoints}) ‚Äì M·∫•t ${bet} Rin`;
                } else {
                    playerWinAmount = bet;
                    outcome = `ü§ù H√≤a ƒëi·ªÉm (${playerPoints})`;
                }
            }

            if (playerWinAmount > 0) {
                await updateUserRin(pdata.user.id, playerWinAmount);
            }

            embed.addFields({ 
                name: pdata.user.displayName, 
                value: `${playerMsg}\n${outcome}`, 
                inline: false 
            });
        }

        // C·∫≠p nh·∫≠t ti·ªÅn cho nh√† c√°i
        const hostNetWinnings = totalHostWinnings - totalHostLosses;
        if (hostNetWinnings > 0) {
            await updateUserRin(game.host.id, hostNetWinnings);
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `üéâ Th·∫Øng r√≤ng: +${hostNetWinnings} Rin`, 
                inline: false 
            });
        } else if (hostNetWinnings < 0) {
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `üí∏ Thua r√≤ng: ${hostNetWinnings} Rin`, 
                inline: false 
            });
        } else {
            embed.addFields({ 
                name: 'üí∞ Nh√† c√°i', 
                value: `ü§ù H√≤a v·ªën: 0 Rin`, 
                inline: false 
            });
        }

        await channel.send({ embeds: [embed] });
    }
    
    delete global.games[channelId];
    console.log('üèÅ === K·∫æT TH√öC END GAME (XJRIN) ===');
}

module.exports = {
    name: 'xjrin',
    description: 'R√∫t b√†i trong game X√¨ D√°ch',
    async execute(message, args) {
        try {
            const channelId = message.channel.id;
            const game = global.games[channelId];

            if (!game) {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå L·ªói!')
                    .setDescription('Kh√¥ng c√≥ b√†n n√†o!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            if (!game.started) {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå L·ªói!')
                    .setDescription('Ch∆∞a b·∫Øt ƒë·∫ßu tr·∫≠n!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
            if (message.author.id !== currentPlayerId) {
                const embed = new EmbedBuilder()
                    .setTitle('‚õî L·ªói!')
                    .setDescription('Ch∆∞a t·ªõi l∆∞·ª£t b·∫°n!')
                    .setColor('#FF0000');
                return await message.reply({ embeds: [embed] });
            }

            const isHost = currentPlayerId === game.host.id;
            const actionView = ActionView.create(isHost);

            const embed = new EmbedBuilder()
                .setTitle('üé¥ H√†nh ƒë·ªông')
                .setDescription(`${message.author} m·ªü giao di·ªán!`)
                .setColor('#0099FF');

            await message.reply({ embeds: [embed], components: [actionView] });

        } catch (error) {
            console.error('L·ªói xjrin:', error);
            await message.reply('‚ùå C√≥ l·ªói x·∫£y ra!');
        }
    },

    // Export ActionView ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng t·ª´ b√™n ngo√†i
    ActionView
}; 