const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const config = require('../../config/config');

module.exports = {
    name: 'announce',
    description: 'G·ª≠i th√¥ng b√°o (Owner only)',
    
    async execute(message, args) {
        // Ch·ªâ owner m·ªõi ƒë∆∞·ª£c d√πng
        if (!config.isOwner(message.author.id)) {
            return message.reply('‚õî L·ªánh n√†y ch·ªâ d√†nh cho owner bot!');
        }

        if (args.length < 2) {
            return this.showHelp(message);
        }

        const type = args[0].toLowerCase();
        const content = args.slice(1).join(' ');

        if (!content || content.trim().length === 0) {
            return message.reply('‚ùå N·ªôi dung th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
        }

        switch (type) {
            case 'server':
                return await this.announceToCurrentServer(message, content);
            case 'all':
                return await this.announceToAllServers(message, content);
            case 'channel':
                return await this.announceToSpecificChannel(message, content);
            case 'help':
                return this.showHelp(message);
            default:
                return message.reply('‚ùå Lo·∫°i th√¥ng b√°o kh√¥ng h·ª£p l·ªá! D√πng `announce help` ƒë·ªÉ xem h∆∞·ªõng d·∫´n.');
        }
    },

    // Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n
    showHelp(message) {
        const embed = new EmbedBuilder()
            .setTitle('üì¢ H∆Ø·ªöNG D·∫™N L·ªÜNH ANNOUNCE')
            .setDescription('**L·ªánh g·ª≠i th√¥ng b√°o cho owner bot**')
            .addFields(
                {
                    name: 'üè† Server hi·ªán t·∫°i',
                    value: '`,announce server <n·ªôi dung>`\nG·ª≠i th√¥ng b√°o trong server n√†y',
                    inline: false
                },
                {
                    name: 'üåê T·∫•t c·∫£ server',
                    value: '`,announce all <n·ªôi dung>`\nG·ª≠i ƒë·∫øn t·∫•t c·∫£ server bot tham gia',
                    inline: false
                },
                {
                    name: 'üìç Channel c·ª• th·ªÉ',
                    value: '`,announce channel <channelID> <n·ªôi dung>`\nG·ª≠i ƒë·∫øn channel ch·ªâ ƒë·ªãnh',
                    inline: false
                },
                {
                    name: 'üìù ƒê·ªãnh d·∫°ng n√¢ng cao',
                    value: 'S·ª≠ d·ª•ng `||` ƒë·ªÉ ng·∫Øt d√≤ng:\n`,announce server Ti√™u ƒë·ªÅ||N·ªôi dung ch√≠nh||Footer`',
                    inline: false
                }
            )
            .setColor('#FF6B35')
            .setFooter({ text: 'RinBot Announcement System' });

        return message.reply({ embeds: [embed] });
    },

    // G·ª≠i th√¥ng b√°o ƒë·∫øn server hi·ªán t·∫°i
    async announceToCurrentServer(message, content) {
        try {
            const embed = this.createAnnouncementEmbed(content, message.author);
            
            const confirmButton = new ButtonBuilder()
                .setCustomId(`announce_confirm_server_${message.author.id}`)
                .setLabel('‚úÖ G·ª≠i th√¥ng b√°o')
                .setStyle(ButtonStyle.Success);

            const cancelButton = new ButtonBuilder()
                .setCustomId(`announce_cancel_${message.author.id}`)
                .setLabel('‚ùå H·ªßy b·ªè')
                .setStyle(ButtonStyle.Secondary);

            const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

            const previewEmbed = new EmbedBuilder()
                .setTitle('üìã XEM TR∆Ø·ªöC TH√îNG B√ÅO')
                .setDescription(`**Server:** ${message.guild.name}\n**Channel:** ${message.channel.name}`)
                .setColor('#FFA500');

            await message.reply({ 
                embeds: [previewEmbed, embed], 
                components: [row] 
            });

        } catch (error) {
            console.error('L·ªói announce server:', error);
            await message.reply('‚ùå C√≥ l·ªói x·∫£y ra khi t·∫°o th√¥ng b√°o!');
        }
    },

    // G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ server  
    async announceToAllServers(message, content) {
        try {
            const guilds = message.client.guilds.cache;
            const embed = this.createAnnouncementEmbed(content, message.author);
            
            const confirmButton = new ButtonBuilder()
                .setCustomId(`announce_confirm_all_${message.author.id}`)
                .setLabel('‚ö†Ô∏è G·ª≠i ƒë·∫øn t·∫•t c·∫£ server')
                .setStyle(ButtonStyle.Danger);

            const cancelButton = new ButtonBuilder()
                .setCustomId(`announce_cancel_${message.author.id}`)
                .setLabel('‚ùå H·ªßy b·ªè')
                .setStyle(ButtonStyle.Secondary);

            const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

            const previewEmbed = new EmbedBuilder()
                .setTitle('üåê XEM TR∆Ø·ªöC TH√îNG B√ÅO TO√ÄN M·∫†NG')
                .setDescription(`**S·∫Ω g·ª≠i ƒë·∫øn:** ${guilds.size} server\n**‚ö†Ô∏è C·∫¢NH B√ÅO: Kh√¥ng th·ªÉ ho√†n t√°c!**`)
                .setColor('#FF0000');

            await message.reply({ 
                embeds: [previewEmbed, embed], 
                components: [row] 
            });

        } catch (error) {
            console.error('L·ªói announce all:', error);
            await message.reply('‚ùå C√≥ l·ªói x·∫£y ra khi t·∫°o th√¥ng b√°o!');
        }
    },

    // G·ª≠i th√¥ng b√°o ƒë·∫øn channel c·ª• th·ªÉ
    async announceToSpecificChannel(message, content) {
        const parts = content.split(' ');
        const channelId = parts[0];
        const announceContent = parts.slice(1).join(' ');

        if (!channelId || !announceContent) {
            return message.reply('‚ùå C√∫ ph√°p: `announce channel <channelID> <n·ªôi dung>`');
        }

        try {
            const channel = await message.client.channels.fetch(channelId);
            if (!channel || !channel.isTextBased()) {
                return message.reply('‚ùå Kh√¥ng t√¨m th·∫•y channel ho·∫∑c channel kh√¥ng ph·∫£i text channel!');
            }

            const embed = this.createAnnouncementEmbed(announceContent, message.author);
            
            const confirmButton = new ButtonBuilder()
                .setCustomId(`announce_confirm_channel_${channelId}_${message.author.id}`)
                .setLabel('‚úÖ G·ª≠i th√¥ng b√°o')
                .setStyle(ButtonStyle.Success);

            const cancelButton = new ButtonBuilder()
                .setCustomId(`announce_cancel_${message.author.id}`)
                .setLabel('‚ùå H·ªßy b·ªè')
                .setStyle(ButtonStyle.Secondary);

            const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

            const previewEmbed = new EmbedBuilder()
                .setTitle('üìç XEM TR∆Ø·ªöC TH√îNG B√ÅO CHANNEL')
                .setDescription(`**Channel:** ${channel.name} (${channel.guild.name})`)
                .setColor('#00FF00');

            await message.reply({ 
                embeds: [previewEmbed, embed], 
                components: [row] 
            });

        } catch (error) {
            console.error('L·ªói announce channel:', error);
            await message.reply(`‚ùå Kh√¥ng th·ªÉ truy c·∫≠p channel: ${error.message}`);
        }
    },

    // T·∫°o embed th√¥ng b√°o
    createAnnouncementEmbed(content, author) {
        const parts = content.split('||').map(part => part.trim());
        
        const embed = new EmbedBuilder()
            .setColor('#FFD700')
            .setTimestamp()
            .setFooter({ 
                text: `RinBot Official ‚Ä¢ By ${author.displayName}`,
                iconURL: author.displayAvatarURL()
            });

        if (parts.length >= 3) {
            embed.setTitle(`üì¢ ${parts[0]}`)
                 .setDescription(parts[1])
                 .setFooter({ 
                     text: `${parts[2]} ‚Ä¢ By ${author.displayName}`,
                     iconURL: author.displayAvatarURL()
                 });
        } else if (parts.length === 2) {
            embed.setTitle(`üì¢ ${parts[0]}`)
                 .setDescription(parts[1]);
        } else {
            embed.setTitle('üì¢ TH√îNG B√ÅO QUAN TR·ªåNG')
                 .setDescription(content);
        }

        return embed;
    },

    // X·ª≠ l√Ω button interactions
    async handleInteraction(interaction) {
        if (!interaction.customId.startsWith('announce_')) return;

        const parts = interaction.customId.split('_');
        const action = parts[1];
        const type = parts[2];
        const userId = parts[parts.length - 1];

        if (interaction.user.id !== userId) {
            return interaction.reply({ content: '‚ùå Ch·ªâ ng∆∞·ªùi t·∫°o th√¥ng b√°o m·ªõi c√≥ th·ªÉ th·ª±c hi·ªán!', flags: 64 });
        }

        if (action === 'cancel') {
            const embed = new EmbedBuilder()
                .setTitle('‚ùå ƒê√É H·ª¶Y TH√îNG B√ÅO')
                .setDescription('Th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c h·ªßy b·ªè.')
                .setColor('#6C757D');

            return interaction.update({ embeds: [embed], components: [] });
        }

        if (action === 'confirm') {
            try {
                await interaction.deferUpdate();
                const originalEmbed = interaction.message.embeds[1];
                
                if (type === 'server') {
                    await this.sendToCurrentServer(interaction, originalEmbed);
                } else if (type === 'all') {
                    await this.sendToAllServers(interaction, originalEmbed);
                } else if (type === 'channel') {
                    const channelId = parts[3];
                    await this.sendToSpecificChannel(interaction, originalEmbed, channelId);
                }

            } catch (error) {
                console.error('L·ªói confirm announce:', error);
                await interaction.editReply({ 
                    content: '‚ùå C√≥ l·ªói x·∫£y ra khi g·ª≠i th√¥ng b√°o!', 
                    embeds: [], 
                    components: [] 
                });
            }
        }
    },

    // G·ª≠i ƒë·∫øn server hi·ªán t·∫°i
    async sendToCurrentServer(interaction, announceEmbed) {
        await interaction.channel.send({ embeds: [announceEmbed] });

        const successEmbed = new EmbedBuilder()
            .setTitle('‚úÖ TH√îNG B√ÅO ƒê√É ƒê∆Ø·ª¢C G·ª¨I')
            .setDescription(`**Server:** ${interaction.guild.name}\n**Channel:** ${interaction.channel.name}`)
            .setColor('#00FF00');

        await interaction.editReply({ embeds: [successEmbed], components: [] });
    },

    // G·ª≠i ƒë·∫øn t·∫•t c·∫£ server
    async sendToAllServers(interaction, announceEmbed) {
        const guilds = interaction.client.guilds.cache;
        let successCount = 0;
        let failCount = 0;

        const progressEmbed = new EmbedBuilder()
            .setTitle('üîÑ ƒêANG G·ª¨I TH√îNG B√ÅO...')
            .setDescription(`ƒêang g·ª≠i ƒë·∫øn ${guilds.size} server...`)
            .setColor('#FFA500');

        await interaction.editReply({ embeds: [progressEmbed], components: [] });

        for (const guild of guilds.values()) {
            try {
                const targetChannel = guild.channels.cache.find(ch => 
                    ch.isTextBased() && 
                    ch.permissionsFor(guild.members.me)?.has(['SendMessages', 'EmbedLinks']) &&
                    (ch.name.includes('general') || ch.name.includes('thong-bao'))
                ) || guild.channels.cache.find(ch => 
                    ch.isTextBased() && 
                    ch.permissionsFor(guild.members.me)?.has(['SendMessages', 'EmbedLinks'])
                );

                if (targetChannel) {
                    await targetChannel.send({ embeds: [announceEmbed] });
                    successCount++;
                } else {
                    failCount++;
                }

                await new Promise(resolve => setTimeout(resolve, 500));

            } catch (error) {
                failCount++;
            }
        }

        const resultEmbed = new EmbedBuilder()
            .setTitle('üìä K·∫æT QU·∫¢ G·ª¨I TH√îNG B√ÅO')
            .setDescription(`**‚úÖ Th√†nh c√¥ng:** ${successCount}/${guilds.size} server\n**‚ùå Th·∫•t b·∫°i:** ${failCount}/${guilds.size} server`)
            .setColor(failCount === 0 ? '#00FF00' : '#FFA500');

        await interaction.editReply({ embeds: [resultEmbed], components: [] });
    },

    // G·ª≠i ƒë·∫øn channel c·ª• th·ªÉ
    async sendToSpecificChannel(interaction, announceEmbed, channelId) {
        const channel = await interaction.client.channels.fetch(channelId);
        await channel.send({ embeds: [announceEmbed] });

        const successEmbed = new EmbedBuilder()
            .setTitle('‚úÖ TH√îNG B√ÅO ƒê√É ƒê∆Ø·ª¢C G·ª¨I')
            .setDescription(`**Channel:** ${channel.name}\n**Server:** ${channel.guild.name}`)
            .setColor('#00FF00');

        await interaction.editReply({ embeds: [successEmbed], components: [] });
    }
}; 